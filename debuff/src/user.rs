// @generated
// This file is @generated by prost-build.
/// How the preferences are stored in the backend. Don't expose
/// this through a service/API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Preferences {
    #[prost(string, tag="1")]
    pub uuid: ::prost::alloc::string::String,
    /// should come across as JSON.
    #[prost(string, tag="2")]
    pub preferences: ::prost::alloc::string::String,
}
/// Backwards compatibility version. Use LoginStorage and
/// LoginWire for new messages.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Login {
    #[prost(string, tag="1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub user_agent: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub login_time: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(message, optional, tag="5")]
    pub logout_time: ::core::option::Option<::pbjson_types::Timestamp>,
}
/// How a login is stored in the backend. Don't send this over the
/// wire.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginStorage {
    /// The UUID of the user. Not the username. Must be set.
    #[prost(string, tag="1")]
    pub user_id: ::prost::alloc::string::String,
    /// The IP address of the user that logged in.
    #[prost(string, optional, tag="2")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    /// The user agent string of the user that logged in.
    #[prost(string, optional, tag="3")]
    pub user_agent: ::core::option::Option<::prost::alloc::string::String>,
    /// The time the user logged in. If you're adding a login, this
    /// will be set automatically by the backend if it's not set.
    #[prost(message, optional, tag="4")]
    pub login_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The time the user logged out. Could be unset if the user
    /// hasn't logged out yet.
    #[prost(message, optional, tag="5")]
    pub logout_time: ::core::option::Option<::pbjson_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginIp {
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginUserAgent {
    #[prost(string, tag="1")]
    pub full: ::prost::alloc::string::String,
}
/// A wire-safe version of a login record.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginWire {
    #[prost(message, optional, tag="1")]
    pub user: ::core::option::Option<UserRef>,
    #[prost(message, optional, tag="2")]
    pub ip: ::core::option::Option<LoginIp>,
    #[prost(message, optional, tag="3")]
    pub user_agent: ::core::option::Option<LoginUserAgent>,
    /// The time the user logged in. If you're adding a login, this
    /// will be set automatically by the backend if it's not set.
    #[prost(message, optional, tag="4")]
    pub login_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The time the user logged out. Could be unset if the user
    /// hasn't logged out yet.
    #[prost(message, optional, tag="5")]
    pub logout_time: ::core::option::Option<::pbjson_types::Timestamp>,
}
/// A list of logins that can go out over the wire.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginListWire {
    #[prost(message, repeated, tag="1")]
    pub logins: ::prost::alloc::vec::Vec<LoginWire>,
}
/// Maintained for backwards compatibility. Use the Wire and Storage versions
/// for new messages
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SavedSearches {
    #[prost(string, tag="1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub saved_searches: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SavedSearchesStorage {
    #[prost(string, tag="1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub saved_searches: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SavedSearchesWire {
    #[prost(message, optional, tag="1")]
    pub user: ::core::option::Option<UserRef>,
    /// Saved searches are stored in a JSON-encoded string.
    #[prost(string, tag="2")]
    pub saved_searches: ::prost::alloc::string::String,
}
/// *
/// A user's information. Represents how the user is stored.
/// Don't use this directly in Request messages.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    #[prost(string, tag="1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub username: ::prost::alloc::string::String,
}
/// How a user can be referred to. Typically only one of them is
/// set. Can be used in Request messages
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserRef {
    /// The username of the user in the database. Must be unique.
    /// It's more likely for a service to have this, which is why
    /// it's listed first. Writing services to use the username
    /// can skip a lookup of the UUID.
    #[prost(string, optional, tag="1")]
    pub username: ::core::option::Option<::prost::alloc::string::String>,
    /// The UUID of the user in the database. A service can have
    /// this, but it's more likely for it to have the username.
    #[prost(string, optional, tag="2")]
    pub uuid: ::core::option::Option<::prost::alloc::string::String>,
}
include!("user.serde.rs");
// @@protoc_insertion_point(module)
